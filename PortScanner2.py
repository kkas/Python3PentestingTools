#!/usr/bin/python3

import socket
import ipaddress
import threading

ports_and_services = {
    7: 'echo',
    20: 'ftp',
    21: 'ftp',
    22: 'ssh',
    23: 'telnet',
    25: 'smtp',
    43: 'whois',
    53: 'dns',
    67: 'dhcp',
    68: 'dhcp',
    80: 'http',
    110: 'pop3',
    123: 'ntp',
    137: 'netbios',
    138: 'netbios',
    139: 'netbios',
    143: 'imap4',
    443: 'https',
    513: 'rlogin',
    540: 'uucp',
    554: 'rtsp',
    587: 'smtp',
    873: 'rsync',
    902: 'vmware',
    989: 'ftps',
    990: 'ftps',
    1194: 'openvpn',
    3306: 'mysql',
    5000: 'unpn',
    8080: 'https-proxy',
    8443: 'https-alt'
}

def TCP_connect(ip, port, open_ports):
  with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.settimeout(5)

    if not s.connect_ex((ip, port)):
      open_ports.append(port)


def construct_verbose_output(hostname, ip, open_ports):
  output = "Open ports for "

  if hostname != ip:
    output += "{} ({})".format(hostname, ip)
  else:
    output += "{}".format(ip)
  output += "\n"

  output += "{:9}{}".format("PORT", "SERVICE")

  for port in open_ports:
    output += ("\n{:<9d}{}".format(port, ports_and_services[port]))
  
  return output


def get_open_ports(target, port_range, verbose=False):
  open_ports = []
  threads = []
  ip = target
  hostname = target

  if not target.replace('.','').isnumeric():
    # Assuming hostname is specified
    try:
      ip = socket.gethostbyname(target)
    except socket.gaierror as e:
      return "Error: Invalid hostname"
  else:
    # Assuming IP addr is specified
    try:
      ipaddress.ip_address(target)
      hostname = socket.gethostbyaddr(target)[0]
    except socket.gaierror as e:
      return "Error: Invalid hostname"
    except ValueError:
      return  "Error: Invalid IP address"
    except socket.herror as e:
      # merly the reverse DNS lookup failed, so keep on.
      pass

  for port in range(port_range[0], port_range[1]+1):
    t = threading.Thread(target=TCP_connect, args=(ip, port, open_ports))
    threads.append(t)

  for t in threads:
    t.start()
  
  for t in threads:
    t.join()

  if verbose:
    if len(open_ports) > 0:
      return construct_verbose_output(hostname, ip, open_ports)
  else:
    return(open_ports) 
    
